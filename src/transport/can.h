#ifndef INC_DEV_CAN
#define INC_DEV_CAN

#ifdef __cplusplus
extern "C" {
#endif
#include "core/app.h"

/* Start of autogenerated OD types */
/* 0x6200: Transport CAN 1null */
typedef struct transport_can_properties {
    uint8_t parameter_count;
    uint8_t tx_port;
    uint8_t tx_pin;
    uint8_t rx_port;
    uint8_t rx_pin;
    int16_t bitrate;
    uint16_t brp;
    uint8_t sjw;
    uint8_t prop;
    uint8_t ph_seg1;
    uint8_t ph_seg2;
    uint8_t phase;
} transport_can_properties_t;
/* End of autogenerated OD types */

struct transport_can {
    actor_t *actor;
    transport_can_properties_t *properties;
    actor_t *canopen;
};


extern actor_class_t transport_can_class;

/* Start of autogenerated OD accessors */
typedef enum transport_can_properties_properties {
  TRANSPORT_CAN_TX_PORT = 0x01,
  TRANSPORT_CAN_TX_PIN = 0x02,
  TRANSPORT_CAN_RX_PORT = 0x03,
  TRANSPORT_CAN_RX_PIN = 0x04,
  TRANSPORT_CAN_BITRATE = 0x05,
  TRANSPORT_CAN_BRP = 0x06,
  TRANSPORT_CAN_SJW = 0x07,
  TRANSPORT_CAN_PROP = 0x08,
  TRANSPORT_CAN_PH_SEG1 = 0x09,
  TRANSPORT_CAN_PH_SEG2 = 0x0A,
  TRANSPORT_CAN_PHASE = 0x0B
} transport_can_properties_properties_t;

/* 0x62XX0B: null */
static inline void transport_can_set_phase(transport_can_t *can, uint8_t value) { 
    actor_set_property_numeric(can->actor, TRANSPORT_CAN_PHASE, (uint32_t)(value), sizeof(uint8_t));
}
static inline uint8_t transport_can_get_phase(transport_can_t *can) {
    return *((uint8_t *) actor_get_property_pointer(can->actor, TRANSPORT_CAN_PHASE));
}
/* End of autogenerated OD accessors */

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif




#ifdef CO_CAN_INTERFACE
#ifdef STMF32F1
#if CO_CAN_RX_FIFO_INDEX == 0 || !defined(CO_CAN_RX_FIFO_INDEX)
void usb_hp_can_tx_isr(void) { CO_CANTxInterrupt(CO->CANmodule); }
void usb_lp_can_rx0_isr(void) { CO_CANRxInterrupt(CO->CANmodule); }
#else
void usb_lp_can_rx1_isr(void) { CO_CANRxInterrupt(CO->CANmodule); }
#endif
#else
#if CO_CAN_INTERFACE == CAN1
#if CO_CAN_RX_FIFO_INDEX == 0
void can1_tx_isr(void) { CO_CANTxInterrupt(CO->CANmodule); }
void can1_rx0_isr(void) { CO_CANRxInterrupt(CO->CANmodule); }
#else
void can1_rx1_isr(void) { CO_CANRxInterrupt(CO->CANmodule); }
#endif
#else
#if CO_CAN_RX_FIFO_INDEX == 0
void can2_tx_isr(void) { CO_CANTxInterrupt(CO->CANmodule); }
void can2_rx0_isr(void) { CO_CANRxInterrupt(CO->CANmodule); }
#else
void can2_rx1_isr(void) { CO_CANRxInterrupt(CO->CANmodule); }
#endif
#endif
#endif
#endif
